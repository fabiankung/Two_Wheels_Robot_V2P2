//////////////////////////////////////////////////////////////////////////////////////////////
//
//	USER DRIVER ROUTINES DECLARATION (PROCESSOR DEPENDENT)
//
//  (c) Copyright 2016-2020, Fabian Kung Wai Lee, Selangor, MALAYSIA
//  All Rights Reserved  
//   
//////////////////////////////////////////////////////////////////////////////////////////////
//
// File             : Drivers_QuadEncoder_V100.c
// Author(s)		: Fabian Kung
// Last modified	: 4 Feb 2020
// Toolsuites		: Microchip MPLAB X IDE v5.30 or above
//                	  MPLAB XC16 C-Compiler v1.41 or above

#include "osmain.h"

// NOTE: Public function prototypes are declared in the corresponding *.h file.


//
// --- PUBLIC VARIABLES ---
//

float       gfOmegaLW = 0.0;            // Rotation velocity of left wheel in rotation/sec.  Positive if the rotates
                                        // rotates in such a way that pushes the robot to move forward.
float       gfOmegaRW = 0.0;            // Rotation velocity of right wheel in rotation/sec.  Polarity convention
                                        // as per left wheel.
float       gfOmegaW = 0.0;             // Average velocity of both wheels in rotation/sec.
long        gnDistanceMoveLW = 0;       // Distance traveled by left wheel in no. of ticks, 32 bits integer. Positive
                                        // if the wheel rotates in such a way that pushes the robot to move forward,
                                        // negative otherwise.
long        gnDistanceMoveRW = 0;       // Distance traveled by right wheel in no. of ticks, 32 bits integer. Polarity
                                        // convention as per left wheel.
long        gnDistanceMoveW = 0;        // Average distance traveled by both wheels in no. of ticks, 32 bits integer.
int         gnHeading = 0;              // This indicates the direction, essentially it is the difference between right and 
                                        // left wheel distance in ticks.  Facing left if > 0, and facing right if < 0 
                                        // (Here we imagine the XY axes being rotated 90 degrees anti-clockwise, and apply 
                                        // standing convention for Polar coordinate.

typedef struct StructProceQuadEncoder
{
    int         nQuadEncoderStatus;     // 0 - Reset.  
                                        // Otherwise - Ready.
                                        // Note: User process can reset the quadrature encoder by setting this
                                        // global variable to 0.  Reseting the quadrature encoder also initialize
                                        // all the velocity and distance variables.
    unsigned int unGearRatio;           // Gear ratio for gearbox connected to motor shaft. 
                                        // Note: If we wish to measure actual motor shaft speed, we should
                                        // set this to 1.
    unsigned int unEncoder_CPR;         // Rotational encoder's count pulse per rotation, 
                                        // For instance for Pololu magnetic encoder for micro-metal DC gear motor,
                                        // this is 12 count-per-rotation.  For my DIY optical encoder with 20 teeths,
                                        // this is 20 count-per-rotation.
    unsigned int unEncoder_Div;         // Quadrature encoder division ratio. Valid value is 1, 2, 4, 8, 16, 32 and 64. 
                                        // We use this parameter to set the no. of ticks per rotation of the wheel. 
                                        // This parameter is used in conjuction with unGearRatio and unEncoder_CPR.
                                        // For instance for a geared DC motor with:
                                        // a) Motor shaft mounted encoder with 12 CPR.
                                        // b) Gear ratio 100:1
                                        // c) unEncoder_DIV = 16.
                                        // Then for each turn of the wheel, 12*100 = 1200 pulses will be generated by
                                        // the quadrature encoder.  This will be divided by 16, thus the effective 
                                        // pulse per rotation of the wheel is 1200/16 = 75 ticks per wheel rotation.
                                        // From experiments, recommends this value to be between 60 to 160.
    int         nDeltaDistance;         // Change in average distance traveled from last read.  Every time this variable
                                        // is read, it will be set to zero by other routines.  Each time the distance
                                        // traveled by the wheels are updated, the change will be added to this 
                                        // variable.  So next time when it is read by other routines, it gives the
                                        // cumulative change in distance traveled.  Be sure to read this variable 
                                        // often to prevent overflow, as there is no mechanism to detect overflow.
    
} DSPIC33E_QEI_DRIVER;

#define     _QUADENCODER_RESET      0
#define     _QUADENDCODER_READY     1
#define     _QUADENCODER_POWERUP    -1

DSPIC33E_QEI_DRIVER    gobjDriverQuadEncoder;

//
// --- PRIVATE VARIABLES ---
//

#define PIN_WH_ENCODLF          _RB9                    // Pin RB9 = Left wheel encoder front sensor output.
#define PIN_WH_ENCODLB          _RB10                   // Pin RB10 = Left wheel encoder back sensor output.
#define PIN_WH_ENCODRF          _RB6                    // Pin RB6 = Right wheel encoder front sensor output.
#define PIN_WH_ENCODRB          _RB7                    // Pin RB7 = Right wheel encoder back sensor output.

//
// --- Process Level Constants Definition --- 
//
// Note: See description below for more detailed explanation.
#define _ENCODER_SCALE_FACTOR   1.0             // Depending on the motor type, gearbox, the actual rotation
                                                // velocity in revolution/sec may be too small for practical
                                                // purpose.  For instance for the HP micrometal gear motor from Pololu
                                                // with 100:1 gear ratio, the rotation velocity ranges from 0 to
                                                // 5.0 only (under no load at 6V, the output shaft rotates at 320 RPM or
                                                // 5.333 round-per-second).  We can use the scale factor to increase the
                                                // magnitude.


#define _DT_US                __TCLK_US*128     // Duration for 1 timer interval, assuming INTDIV bits are set to 0b111.
                                                // or 128:1.
                                                // Note: 21 Dec 2018, the Interval Timer in the Quadrature encoder is incremented
                                                // on both L-to-H and H-to-L transitions of the interval clock, see documentation 
                                                // of QEI in dsPIC33E. Also there is a typo error in the Microchip dsPIC33E/PIC24E
                                                // family reference for QEI, for the bit setting for INTDIV.  The document state
                                                // 0b111 corresponds to 256:1, whereas in the datasheet 0b111 for INTDIV corresponds
                                                // to 128:1.  I believe the datasheet is correct from experimentation.
//#define _DT_US                __TCLK_US*64      // Duration for 1 timer interval, assuming INTDIV bits are set to 0b110.  
                                                

///
/// Process name	: Proce_QuadEncoder_Driver
///
/// Author          : Fabian Kung
///
/// Last modified	: 4 Feb 2020
///
/// Code version	: 1.05
///
/// Processor		: dsPIC33EP256MU8XX family.
///                       
///
/// Processor/System Resource 
/// PINS            : 1. Pin RB6 = Remappable I/O RPI38, input. For right wheel front sensor.
///                   2. Pin RB7 = Remappable I/O RPI39, input. For right wheel back sensor.
///                   3. Pin RB9 = Remappable I/O RPI41, input. For left wheel front sensor.
///                   4. Pin RB10 = Remappable I/O RPI42, input. For left wheel sensor.
///
/// MODULES         : 1. QEI1 and 2 (Internal).
///       
/// RTOS            : Ver 1 or above, round-robin scheduling.
///
/// Global variable	: See declaration of public variables.
///
/// Description		: This driver serves as the interface between user process and the QEI1 modules
///                   of the dsPIC33E micro-controller.  It is assumed QEI1 is linked to Left Wheel, while
///                   QEI2 is linked to Right Wheel.  It measures the rotation speed as mesaured by QEI1 and
///                   QEI2 in rotation/second, and also the angle travelled in no. of ticks.
///
///                   Example of Usage:
///                   To use, the user needs to (follow the sequence):
///                   1) Set the variables gobjDriverQuadEncoder.unGearRatio and gunEncoder_CPR for each geared
///                   DC motor and encoder pair properly.  Here unfortunately we do not support independent
///                   gear ratio and encoder CPR for left and right motors.
///                   2) Set gobjDriverQuadEncoder.nQuadEncoderStatus = _QUADENCODER_RESET.
///                   3) Once gobjDriverQuadEncoder.nQuadEncoderStatus = _QUADENCODER_READY, the user routines can then monitor the global 
///                   variables for distance traveled and wheel velocity and direction (heading) as often
///                   as needed.  To reset all global variables and internal counters in this driver to 0
///                   again, the user need to set gnQuadEncoderStatus = 0.  Then wait for 1 system tick before
///                   monitoring the global variables again.  A summary of the global variables:
///                     gfOmegaLW - Current rotation velocity of left wheel in rotation/sec.
///                     gfOmegaRW - Current rotation velocity of right wheel in rotation/sec.
///                     gfOmegaW - Current average velocity of both wheels in rotation/sec.
///                     gnDistanceMoveLW - Current distance traveled by left wheel in no. of ticks, 32 bits integer.
///                     gnDistanceMoveRW - Current distance traveled by right wheel in no. of ticks, 32 bits integer.
///                     gnDistanceMoveW - Current average distance traveled by both wheels in no. of ticks, 32 bits integer.
///                     gnHeading - This indicates the current direction, essentially the difference between right and left 
///                                 wheel distance.  Facing right if > 0, and facing left if < 0.
///                     nDeltaDistance - This is the cumulative change in average distance traveled.  After each calculation
///                                      of the change in gnDistanceMoveW, the change in value compare to previous value
///                                      of gnDistanceMoveW is added to this variable.  In combination with gnHeading, this
///                                      variable can be used to track the change of the machine movement by another process,
///                                      i.e. it can be used to compute the pose of the machine.  Every time after reading 
///                                      the value stored in nDeltaDistance, the external process should clear it to zero.
///                                      For instance as illustrated in the following codes:
///                                              gbytTXbuffer[26] = gobjDriverQuadEncoder.nDeltaDistance + 127;
///                                              gobjDriverQuadEncoder.nDeltaDistance = 0;
///
///                   During program execution, the user can reset this driver and all the global variables by repeating
///                   steps (1) to (3) above.
/// 
/// --- Some notes on fixing the value of fRotationCoeff and velocity computation, 31 March 2016 ---
/// The rotation coefficient should ALWAYS be within 50 to 500.0 to prevent overflow
/// and excessive error in the velocity computation.
///
/// Velocity = fRotationCoeff/INT1HLDL;
///                                          
/// Where fRotationCoeff = _ENCODER_SCALE_FACTOR/(_DT_US*_ENCODER_CPR*0.000001*_GEAR_RATIO);
/// _ENCODER_SCALE_FACTOR = 0.1 or 1 for now.
///
/// Example 1: Pololu micrometal gear motor with 100:1 gear, and hall-effect magnetic encoder mounted on the motor. 
/// This encoder is connected to QEI1.
/// _ENCODER_CPR = 12
/// _GEAR_RATIO = 100
/// _ENCODER_SCALE_FACTOR = 1.0
/// INTDIV = 128
/// _DT_US = 0.01667*128 usec (assume processor is running at 120 MHz clock, divide by 2 for 1 instruction cycle)
/// fRotationCoeff = 390.5469
/// Note: XC16 uses 32 bits for single precision floating point (IEEE-754)
/// in "float" declaration.  This has 1 sign bit, 8 exponent bits, and 23
/// fraction bits.  
/// Max velocity corresponds to INT1HLDL Interval Timer = 1: 
///  Vmax = 390.5469 rotation/sec
/// Min velocity corresponds to INT1HLDL Interval Timer = 65535:
///  Vmin = 0.00596 rotation/sec
/// Hence anything less than 0.00298 will be approximated as zero.
///
/// Example 2: Optical quadrature with 20 CPR encoder mounted on the wheel.  Here the gear ratio used is not considered
/// as the quadrature encoder is mounted on the output shaft of the gearbox.
/// _ENCODER_CPR = 20
/// _GEAR_RATIO = 1
/// _ENCODER_SCALE_FACTOR = 0.1
/// INTDIV = 128
/// _DT_US = 0.01667*128 usec
/// fRotationCoeff = 2343.281
/// Max velocity corresponds to Interval Timer = 1: 
///  Vmax = 2343.281 rotation/sec
/// Min velocity corresponds to Interval Timer = 65535:
///  Vmin = 0.0358 rotation/sec
/// Hence anything less than 0.01788 will be approximated as zero.

void Proce_QuadEncoder_Driver(TASK_ATTRIBUTE *ptrTask)
{

    static unsigned int unPosCount1 = 0;
    static unsigned int unPosCount2 = 0;
    static int nPolarity1 = 0;
    static int nPolarity2 = 0;
    static long nlCountLW = 0;
    static long nlCountRW = 0;
    static float    fRotationCoeff = 0.0;    
    static unsigned int unDivide = 4;
    static long nlDistanceOld = 0;
    
    float           fTemp;
    int             nTemp;
    long            nlTemp;
    unsigned int    unTemp, unTemp2;
    
    if (ptrTask->nTimer == 0)
    {
        switch (ptrTask->nState)
        {
            case 0: // State 0 - Quadrature Encoder 1 & 2 Initialization.
		    // Setup IO pins mode and configure the re-mappable peripheral pins:
                
                gobjDriverQuadEncoder.nQuadEncoderStatus = _QUADENCODER_POWERUP;   // Indicate quadrature encoder is just powered up.
                gobjDriverQuadEncoder.unEncoder_CPR = 1;
                gobjDriverQuadEncoder.unEncoder_Div = 1;
                gobjDriverQuadEncoder.unGearRatio = 1;
                      
                TRISBbits.TRISB6 = 1;               // RB6 and RB7 to inputs.
                TRISBbits.TRISB7 = 1;
                TRISBbits.TRISB9 = 1;               // RB9 and RB10 to inputs.
                TRISBbits.TRISB10 = 1;

                RPINR14bits.QEA1R = 0b0100110;      // Set RB6 (RPI38) to QEA1.
                RPINR14bits.QEB1R = 0b0100111;      // Set RB7 (RPI39) to QEB1.
                RPINR16bits.QEA2R = 0b0101001;      // Set RB9 (RPI41) to QEB2.
                RPINR16bits.QEB2R = 0b0101010;      // Set RB10 (RPI42) to QEA2.

                //RPINR14bits.QEA1R = 0b0101001;      // Set RB6 (RPI38) to QEA2.
                //RPINR14bits.QEB1R = 0b0101010;      // Set RB7 (RPI39) to QEB2.
                //RPINR16bits.QEA2R = 0b0100110;      // Set RB9 (RPI41) to QEA1.
                //RPINR16bits.QEB2R = 0b0100111;      // Set RB10 (RPI42) to QEB1.

                // --- Settings for Quadrature Encoder 1 (Left Wheel) ---
                QEI1CONbits.QEISIDL = 1;            // Discontinue module operation in Idle mode.
                QEI1CONbits.INTDIV = 0b111;         // Set clock source divider ratio, 1:128 pre-scalar value.
                                                    // For instance for Fcyc = 66 MHz, the clock frequency would
                                                    // be 257.82 kHz.  We need to ensure that the clock frequency
                                                    // is at least 40x the sampling rate of the control system. 
                                                    // For instance if the sampling rate of the control system 
                                                    // is 1 kHz, then minimum clock frequency is 40 kHz.
                                                    // Note: 21 Dec 2018, Fabian Kung.
                                                    // There is a typo error in the Microchip dsPIC33E/PIC24E
                                                    // family reference for QEI, for the bit setting for INTDIV.  
                                                    // The document states 0b111 corresponds to 256:1, whereas in 
                                                    // the datasheet 0b111 for INTDIV corresponds
                                                    // to 128:1.  I believe the datasheet is correct from 
                                                    // my experimentation.                
                //QEI1CONbits.INTDIV = 0b110;         // 1:64 pre-scalar value.
                QEI1CONbits.PIMOD = 0b000;          // Index input event does not affect position counter.
                QEI1CONbits.IMV = 0b000;            // Index input event does not affect position counter.
                QEI1CONbits.CCM = 0b00;             // Quadrature Encoder mode.

                //QEI1IOCbits.FLTREN = 0;             // Input pin digital filter is disabled.
                QEI1IOCbits.FLTREN = 1;             // Input pin digital filter is enabled.
                QEI1IOCbits.QFDIV = 0b010;          // Digital filter clock divide = 4:1.
                QEI1IOCbits.OUTFNC = 0b00;          // Output is disabled.

                // --- Settings for Quadrature Encoder 2 (Right Wheel) ---
                //QEI2CONbits.QEISIDL = 1;            // Discontinue module operation in Idle mode.
                QEI2CONbits.INTDIV = 0b111;         // 1:128 pre-scalar value.
                //QEI2CONbits.INTDIV = 0b110;         // 1:64 pre-scalar value.
                QEI2CONbits.PIMOD = 0b000;          // Index input event does not affect position counter.
                QEI2CONbits.IMV = 0b000;            // Index input event does not affect position counter.
                QEI2CONbits.CCM = 0b00;             // Quadrature Encoder mode.
                //QEI2IOCbits.FLTREN = 0;             // Input pin digital filter is disabled.
                QEI2IOCbits.FLTREN = 1;             // Input pin digital filter is enabled.
                QEI2IOCbits.QFDIV = 0b010;          // Digital filter clock divide = 4:1.
                QEI2IOCbits.OUTFNC = 0b00;          // Output is disabled.   
                OSSetTaskContext(ptrTask, 1, 100*__NUM_SYSTEMTICK_MSEC); // Next state = 1, timer = 100 msec.
                break;
                
            case 1: // State 1 - Wait for user to start the quadrature encoder.
                if (gobjDriverQuadEncoder.nQuadEncoderStatus == _QUADENCODER_POWERUP)            // If it is still under power up status.
                {
                    OSSetTaskContext(ptrTask, 1, 10*__NUM_SYSTEMTICK_MSEC); // Next state = 1, timer = 10 msec.
                }
                else
                {
                    OSSetTaskContext(ptrTask, 2, 1);    // Next state = 2, timer = 1.
                }
                break;
                
            case 2: // State 2 - Reset, initialization of global and static variables and Quadrature Encoder 1 & 2.
                fTemp = (gobjDriverQuadEncoder.unEncoder_CPR)*(gobjDriverQuadEncoder.unGearRatio)*0.000001; 
                fRotationCoeff = _ENCODER_SCALE_FACTOR/(_DT_US*fTemp);                   
                                                    // _ENCODER_SCALE_FACTOR/(_DT_US*_ENCODER_CPR*0.000001*_GEAR_RATIO);
                                                    // Calculate the rotation coefficient. This value divided 
                                                    // by the interval timer reading of the quadrature encoder 
                                                    // will give the rotation velocity of the shaft output in 
                                                    // revolution/second.
                
                switch(gobjDriverQuadEncoder.unEncoder_Div)              // Set the quadrature encoder divider ratio.
                {
                    case 1:
                        unDivide = 0;
                        break;
                        
                    case 2:
                        unDivide = 1;
                        break;
                        
                    case 4:
                        unDivide = 2;
                        break;  
                        
                    case 8:
                        unDivide = 3;
                        break; 
                        
                   case 16: 
                        unDivide = 4;
                        break;  
                        
                    case 32:
                        unDivide = 5;
                        break;
                   
                   default: // Divide by 64.
                        unDivide = 6;
                                                      
                }
                
                unPosCount1 = 32768;                // To write to the 32 bits position counter register, we
                                                    // update the 16-bits POS1HLD register.  When lsw (least 
                                                    // significant word) of the data is written into POS1CNTL,
                                                    // the value in POS1HLD will be transferred to POS1CNTH 
                                                    // simultaneously.  32768 is equivalent to 0x8000 for 16 bits
                                                    // unsigned integer.
                POS1HLD = 0;                        // Upper 16 bits word.
                POS1CNTL = unPosCount1;             // Initialize the position counter. Only the lower
                                                    // 16 bits word is used, the upper word is ignored.

                unPosCount2 = 32768;                // To write to the 32 bits position counter register, we
                                                    // update the 16-bits POS2HLD register.  When lsw (least 
                                                    // significant word) of the data is written into POS2CNTL,
                                                    // the value in POS2HLD will be transferred to POS2CNTH 
                                                    // simultaneously.
                POS2HLD = 0;                        // Upper 16 bits word.
                POS2CNTL = unPosCount2;             // Initialize the position counter. Only the lower
                                                    // 16 bits word is used, the upper word is ignored.
                nlCountLW = 0;
                nlCountRW = 0;
                gfOmegaLW = 0.0;
                gfOmegaRW = 0.0;
                gfOmegaW = 0.0;
                gnDistanceMoveLW = 0;
                gnDistanceMoveRW = 0;
                gnDistanceMoveW = 0;     
                nlDistanceOld = 0;
                gobjDriverQuadEncoder.nDeltaDistance = 0;
                gnHeading = 0;
                QEI1CONbits.QEIEN = 1;              // Enable quadrature encoder 1.
                QEI2CONbits.QEIEN = 1;              // Enable quadrature encoder 2.
                
                gobjDriverQuadEncoder.nQuadEncoderStatus = _QUADENDCODER_READY;   // Indicate quadrature encoder is ready
                
                OSSetTaskContext(ptrTask, 3, 1*__NUM_SYSTEMTICK_MSEC); // Next state = 3, timer = 1 msec.
            break;
			
            case 3: // State 3 - Measure the quadrature encoder position counter and interval timer, then
                    // use this info to determine rotation direction and speed.
                    // To detect rotation direction: we compare the initial value of the position counter
                    // POS1HLD:POS1CNTL with the value in the next cycle.
                    // To measure speed: we measure the duration between phase A and B of the quadrature
                    // encoder inputs.  See the reference manual for further info.

                // Check QEI1 state (default right wheel).
                if (unPosCount1 > POS1CNTL)         // Check if position counter register POS1CNTH:POS1CNTL value,
                {                                   // increases, decreases or unchanged.
                    nPolarity1 = 1;                 // Clockwise.
                    unPosCount1 = 32768;            // Reload 32-bits position counter register with
                    POS1HLD = 0;                    // value from unPosCount, upper 16-bits word is
                    POS1CNTL = unPosCount1;         // ignored.
                    nlCountRW++;                     // Update tick counter.
                    gnDistanceMoveRW = nlCountRW>>unDivide; 
                                                     // Convert encoder ticks to distance tick, Divide by 2,4,6 or 16. 
                                                     // Assuming 12 CPR encoder on the motor shaft,
                                                     // distance counter will increment/decrement by 1 for every
                                                     // every 1.333 rotation of the motor shaft or 
                                                     // (1.333/Gear_ratio)x(2pi) radian rotation of the wheel.
                                                     // About 75 count per rotation or the wheel for 100:1 gearbox.                        
                }
                else if (unPosCount1 < POS1CNTL)     // Decreases.
                {
                    nPolarity1 = -1;                 // Anti-clockwise.
                    unPosCount1 = 32768;
                    POS1HLD = 0;                    // Upper 16 bits word.
                    POS1CNTL = unPosCount1;         // Initialize the position counter. Only the lower
                                                    // 16 bits word is used, the upper word is ignored.
                    nlCountRW--;                    // Update tick counter.
                    gnDistanceMoveRW = nlCountRW>>unDivide; 
                                                    // Convert encoder ticks to distance tick, Divide by 2,4,6 or 16. 
                                                    
                }
                else                                // Unchanged.
                {
                    
                }

                unTemp = INT1HLDL;                  // Read the lower word of the 32 bits Interval Timer counter.  
                unTemp2 = INT1HLDH;                 // Read the upper word of the 32 bits Interval Timer counter.                                     
                                                    // The upper 16 bits is ignored in velocity calculation to save
                                                    // computation time, but is checked for overflow of the lower word.
           
                if (unTemp2 > 0)                    // Check for overflow of lower 16 bits.
                {
                    gfOmegaRW = 0.0;                // Approximate the velocity to 0.0 when lower 16 bits of the counter
                                                    // overflow.  This means the rotation is so slow that the timer
                                                    // overflow its lower 16 bits counter.  Therefore we should keep 
                                                    // _ROTATION_COEF < 50000 to prevent
                                                    // excessive truncation error.  For instance if _ROTATION_COEF = 50000
                                                    // and the Interval Timer counter = 65526, this implies INT1HLDL = 0
                                                    // and INT1HLDH = 1, gfOmegaW = +-0.7629, but we set it to 0.0.                                    
                }
                else                                // No overflow, compute actual rotation velocity.
                {
                    if (unTemp != 0)                 // To prevent divide-by-zero error.  
                    {              
                        gfOmegaRW = fRotationCoeff/unTemp;   // Calculate the rotation speed.
                        if (nPolarity1 < 0)             // Add in direction of rotation.
                        {
                            gfOmegaRW = -gfOmegaRW;   
                        }
                    }
                }
                
                // Check QEI2 state (default left wheel).
                if (unPosCount2 < POS2CNTL)         // Check if position counter register value increases,
                {                                   // decreases or unchanged.
                    nPolarity2 = 1;
                    unPosCount2 = 32768;            // Reload 32-bits position counter register with
                    POS2HLD = 0;                    // value from unPosCount, upper 16-bits word is
                    POS2CNTL = unPosCount2;         // ignored.
                    nlCountLW++;                     // Update tick counter.
                    gnDistanceMoveLW = nlCountLW>>unDivide; 
                                                     // Convert encoder ticks to distance tick, Divide by 2,4,6 or 16. 
                                                     // Assuming 12 CPR encoder on the motor shaft,
                                                     // distance counter will increment/decrement by 1 for every
                                                     // every 1.333 rotation of the motor shaft or 
                                                     // (1.333/Gear_ratio)x(2pi) radian rotation of the wheel.
                                                     // About 75 count per rotation or the wheel for 100:1 gearbox.    
                }
                else if (unPosCount2 > POS2CNTL)     // Decreases.
                {
                    nPolarity2 = -1;
                    unPosCount2 = 32768;
                    POS2HLD = 0;                    // Upper 16 bits word.
                    POS2CNTL = unPosCount2;         // Initialize the position counter. Only the lower
                                                    // 16 bits word is used, the upper word is ignored.
                    nlCountLW--;                    // Update tick counter.
                    gnDistanceMoveLW = nlCountLW>>unDivide; 
                                                    // Convert encoder ticks to distance tick, Divide by 2,4,6 or 16. 
                }
                else                                // Unchanged.
                {

                }

                unTemp = INT2HLDL;                  // Read the lower word of the 32 bits Interval Timer counter.  
                unTemp2 = INT2HLDH;                 // Read the upper word of the 32 bits Interval Timer counter.                                     
                                                    // The upper 16 bits is ignored in velocity calculation to save
                                                    // computation time, but is checked for overflow of the lower word.
                if (unTemp2 > 0)                    // Check for overflow of lower 16 bits.
                {
                    gfOmegaLW = 0.0;                // Approximate the velocity to 0.0 when lower 16 bits of the counter
                                                    // overflow.  Therefore we should keep _ROTATION_COEF < 50000 to prevent
                                                    // excessive truncation error.  For instance if _ROTATION_COEF = 50000
                                                    // and the Interval Timer counter = 65526, this implies INT1HLDL = 0
                                                    // and INT1HLDH = 1, gfOmegaW = +-0.7629, but we set it to 0.0.
                }
                else                                // No overflow, compute actual rotation velocity.
                {
                    if (unTemp != 0)                 // To prevent divide-by-zero error.  
                    {                               
                        gfOmegaLW = fRotationCoeff/unTemp;   // Calculate the rotation speed.
                        if (nPolarity2 < 0)             // Add in direction of rotation.
                        {
                            gfOmegaLW = -gfOmegaLW;   
                        }                                      
                    }                         
                }                
                OSSetTaskContext(ptrTask, 4, 1);    // Next state = 4, timer = 1.
            break;

            case 4: // State 4 - Perform secondary floating points calculations and other mathematical operations
                    // involving long integers.  We try not to perform all floating points calculations
                    // within a single state, to prevent bandwidth overflow!  
                gfOmegaW = 0.5*(gfOmegaLW + gfOmegaRW);             // Compute average velocity of wheels.
                nlTemp = gnDistanceMoveLW + gnDistanceMoveRW;       // Compute the average distance traveled.  Here a long integer
                gnDistanceMoveW = nlTemp >> 1;                      // is used to prevent overflow. Divide by 2 (take average).
                gnHeading = gnDistanceMoveRW - gnDistanceMoveLW;    // Compute the direction or heading.               
                nTemp = gnDistanceMoveW - nlDistanceOld;            // Compute change in distance since last instance.
                nlDistanceOld = gnDistanceMoveW;                    // Update previous distance reading.
                gobjDriverQuadEncoder.nDeltaDistance = gobjDriverQuadEncoder.nDeltaDistance + nTemp;    // Calculate cumulative change in distance.
                if (gobjDriverQuadEncoder.nQuadEncoderStatus == _QUADENCODER_RESET)           // Check status setting, note that this global variable
                                                        // can be modified by other process.
                {
                    OSSetTaskContext(ptrTask, 2, 1);    // Next state = 2, timer = 1.
                }
                else
                {
                    OSSetTaskContext(ptrTask, 3, 1);    // Next state = 3, timer = 1.
                }                
                break;
                
            default:
                gunOSError = gunOSError | 0x0001;   // Set OS error bit 0.
                OSSetTaskContext(ptrTask, 0, 1); // Back to state = 0, timer = 1.
            break;
        }
    }
}


